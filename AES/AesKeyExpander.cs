using System;
using System.Collections.Generic;
using System.Linq;
using AES.Listeners;
using AES.Models;

namespace AES
{
    public class AesKeyExpander
    {
        private readonly IAesKeyExpanderListener listener;
        private readonly SBox sBox;

        public AesKeyExpander(IAesKeyExpanderListener listener)
        {
            this.listener = listener;
            this.sBox = new SBox();
        }

        public IEnumerable<byte[]> ExpandKey(byte[] @in)
        {
            int nk = 4; // Number of input words.
            int nb = 4; // Number of words in a round.
            int expectedByteCount = nk * 4;
            if (@in.Length != expectedByteCount)
            {
                throw new ArgumentOutOfRangeException("@in", $"The key is supposed to consist of {expectedByteCount} bytes");
            }

            int nr = nk + 6;

            IList<byte[]> allRoundWords = new List<byte[]>();
            byte[] temp;

            for (int i = 0; i < nk; i++)
            {
                byte[] word = new byte[4];
                for (int j = 0; j < 4; j++)
                {
                    word[j] = @in[4 * i + j];
                }

                allRoundWords.Add(word);
                listener.ListenToWord(word, i, "Copy word");
            }

            for (int i = nk; i < nb * (nr + 1); i++)
            {
                temp = allRoundWords[i - 1];
                listener.ListenToWord(temp, i, "Temp");

                if (i % nk == 0)
                {
                    byte[] rotatedWord = RotateWord(temp);
                    listener.ListenToWord(rotatedWord, i, "After rotation");

                    byte[] substitutedWord = sBox.Subbyte(new ByteArray(rotatedWord, 2)).Bytes1dArray;
                    listener.ListenToWord(substitutedWord, i, "After substitution");

                    byte[] rcon = RCON(i / nk);
                    listener.ListenToWord(rcon, i, "RCON");

                    byte[] afterRCON = substitutedWord.Select((x, index) => (byte)(x ^ rcon[index])).ToArray();
                    listener.ListenToWord(afterRCON, i, "After RCON");

                    temp = afterRCON;
                }

                byte[] someWord = allRoundWords[i - nk];
                listener.ListenToWord(someWord, i, "Word i - nk");

                byte[] roundWord = someWord.Select((x, index) => (byte)(x ^ temp[index])).ToArray();
                listener.ListenToWord(roundWord, i, "Last step");

                allRoundWords.Add(roundWord);
            }

            return allRoundWords;
        }

        private byte[] RotateWord(byte[] @in)
        {
            if (@in.Length != 4)
            {
                throw new ArgumentOutOfRangeException("@in", $"The rotation operation is supported only for words with length 4");
            }

            byte[] rotatedWord = new byte[] { @in[1], @in[2], @in[3], @in[0] };
            return rotatedWord;
        }
        
        private byte[] RCON(int iteration)
        {
            byte firstByte = 1;
            for (int i = 1; i < iteration; i++)
            {
                byte multiplication = (byte)(firstByte << 1);           // Shift bits once to the left - aka multiply by 2.
                byte firstBit = (byte)(firstByte >> 7);                 // Get a 0 byte or 1 byte by shifting the first bit to the last position.
                byte reductionModulus = (byte)(283 & -firstBit);        // 283 is the x^8 + x^4 + x^3 + x + 1 polynomial. This operation results in either 0 or 11b.
                firstByte = (byte)(multiplication ^ reductionModulus);  // This basically applies the value generated by the constant polynomial and applies it as modulus to the multiplied value, so as to escape going over 8 bits.
            }

            return new byte[] { firstByte, 0, 0, 0 };
        }
    }
}
